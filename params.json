{"tagline":"Illustrated With Python","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Introduction\r\n============\r\n\r\nRecently at work I have been using the\r\n[PyCrypto](https://www.dlitz.net/software/pycrypto/) libraries quite\r\na bit. The documentation is pretty good, but there are a few areas\r\nthat took me a bit to figure out. In this post, I’ll be writing up\r\na quick overview of the PyCrypto library and cover some general\r\nthings to know when writing cryptographic code in general. I’ll go\r\nover symmetric, public-key, hybrid, and message authentication\r\ncodes. Keep in mind this is a quick introduction and a lot of gross\r\nsimplifications are made. For a more complete introduction to\r\ncryptography, take a look at the references at the end of this\r\narticle. This article is just an appetite-whetter - if you have a\r\nreal need for information security you should hire an expert. Real\r\ndata security goes beyond this quick introduction (you wouldn’t\r\ntrust the design and engineering of a bridge to a student with a\r\nquick introduction to civil engineering, would you?)\r\n\r\nSome quick terminology: for those unfamiliar, I introduce the following\r\nterms:\r\n\r\n* plaintext: the original message\r\n\r\n* ciphertext: the message after cryptographic transformations are\r\napplied to obscure the original message.\r\n\r\n* encrypt: producing ciphertext by applying cryptographic transformations\r\nto plaintext.\r\n\r\n* decrypt: producing plaintext by applying cryptographic transformations\r\nto ciphertext.\r\n\r\n* cipher: a particular set of cryptographic transformations providing\r\nmeans of both encryption and decryption.\r\n\r\n* hash: a set of cryptographic transformations that take a large\r\ninput and transform it to a unique (typically fixed-size) output.\r\nFor hashes to be cryptographically secure, collisions should be\r\npractically nonexistent. It should be practically impossible to\r\ndetermine the input from the output.\r\n\r\nCryptography is an often misunderstood component of information\r\nsecurity, so an overview of what it is and what role it plays is in\r\norder. There are four major roles that cryptography plays:\r\n\r\n* confidentiality: ensuring that only the intended recipients receive\r\nthe plaintext of the message.\r\n\r\n* data integrity: the plaintext message arrives unaltered.\r\n\r\n* entity authentication: the identity of the sender is verified.\r\nAn entity may be a person or a machine.\r\n\r\n* message authentication: the message is verified as having been\r\nunaltered.\r\n\r\nNote that cryptography is used to obscure the contents of a message and\r\nverify its contents and source. It will **not** hide the fact that two\r\nentities are communicating.\r\n\r\nThere are two basic types of ciphers: symmetric and public-key ciphers.\r\nA symmetric key cipher employs the use of shared secret keys. They also\r\ntend to be much faster than public-key ciphers. A public-key cipher is\r\nso-called because each key consists of a private key which is used to\r\ngenerate a public key. Like their names imply, the private key is kept\r\nsecret while the public key is passed around. First, I’ll take a look at\r\na specific type of symmetric ciphers: block ciphers.\r\n\r\nBlock Ciphers\r\n=============\r\n\r\nThere are two further types of symmetric keys: stream and block\r\nciphers.  Stream ciphers operate on data streams, i.e. one byte at\r\na time. Block ciphers operate on blocks of data, typically 16 bytes\r\nat a time. The most common block cipher and the standard one you\r\nshould use unless you have a very good reason to use another one\r\nis the\r\n[AES](https://secure.wikimedia.org/wikipedia/en/wiki/Advanced_Encryption_Standard)\r\nblock cipher, also documented in [FIPS PUB\r\n197](http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf). AES\r\nis a specific subset of the Rijndael cipher. AES uses block size\r\nof 128-bits (16 bytes); data should be padded out to fit the block\r\nsize - the length of the data block must be multiple of the block\r\nsize. For example, given an input of `ABCDABCDABCDABCD ABCDABCDABCDABCD`\r\nno padding would need to be done.  However, given `ABCDABCDABCDABCD\r\nABCDABCDABCD` an additional 4 bytes of padding would need to be\r\nadded. A common padding scheme is to use `0x80` as the first byte\r\nof padding, with `0x00` bytes filling out the rest of the padding.\r\nWith padding, the previous example would look like:\r\n`ABCDABCDABCDABCD ABCDABCDABCD\\x80\\x00\\x00\\x00`.\r\n\r\nWriting a padding function is pretty easy:\r\n\r\n        def pad_data(data):\r\n            # return data if no padding is required\r\n            if len(data) % 16 == 0: \r\n                return data\r\n\r\n            # subtract one byte that should be the 0x80\r\n            # if 0 bytes of padding are required, it means only\r\n            # a single \\x80 is required.\r\n\r\n            padding_required     = 15 - (len(data) % 16)\r\n\r\n            data = '%s\\x80' % data\r\n            data = '%s%s' % (data, '\\x00' * padding_required)\r\n\r\n            return data\r\n\r\nSimilarly, removing padding is also easy:\r\n\r\n        def unpad_data(data):\r\n            if not data: \r\n                return data\r\n\r\n            data = data.rstrip('\\x00')\r\n            if data[-1] == '\\x80':\r\n                return data[:-1]\r\n            else:\r\n                return data\r\n\r\nI’ve included these functions in the example code for this tutorial.\r\n\r\nEncryption with a block cipher requires selecting a [block\r\nmode](https://secure.wikimedia.org/wikipedia/en/wiki/Block cipher\r\nmodes of operation). By far the most common mode used is **cipher\r\nblock chaining** or *CBC* mode. Other modes include *counter (CTR)*,\r\n*cipher feedback (CFB)*, and the extremely insecure *electronic\r\ncodebook (ECB)*. CBC mode is the standard and is well-vetted, so I\r\nwill stick to that in this tutorial.  Cipher block chaining works\r\nby XORing the previous block of ciphertext with the current block.\r\nYou might recognise that the first block has nothing to be XOR’d\r\nwith; enter the [*initialisation\r\nvector*](https://secure.wikimedia.org/wikipedia/en/wiki/Initialization_vector).\r\nThis comprises a number of randomly-generated bytes of data the\r\nsame size as the cipher’s block size. This initialisation vector\r\nshould be random enough that it cannot be recovered. One manner of\r\ndoing this is to combine a standard UNIX timestamp with a block-size\r\ngroup of random data, using a standard hashing algorithm such as\r\nSHA1 to make it unique.\r\n\r\nOne of the most critical components to encryption is properly\r\ngenerating random data. Fortunately, most of this is handled by the\r\nPyCrypto library’s `Crypto.Random.OSRNG module`. You should know\r\nthat the more entropy sources that are available (such as network\r\ntraffic and disk activity), the faster the system can generate\r\ncryptographically-secure random data. I’ve written a function that\r\ncan generate a\r\n[*nonce*](https://secure.wikimedia.org/wikipedia/en/wiki/Cryptographic_nonce)\r\nsuitable for use as an initialisation vector. This will work on a\r\nUNIX machine; the comments note how easy it is to adapt it to a\r\nWindows machine. This function requires a version of PyCrypto at\r\nleast 2.1.0 or higher.\r\n\r\n        import time\r\n        import Crypto.Random.OSRNG.posix\r\n\r\n        def generate_nonce():\r\n            rnd = Crypto.Random.OSRNG.posix.new().read(BLOCK_SIZE)\r\n            rnd = '%s%s' % (rnd, str(time.time()))\r\n            nonce = Crypto.Hash.MD5.new(data = rnd)\r\n        \r\n            return nonce.digest()\r\n\r\nI will note here that the python \\`random\\` module is completely\r\nunsuitable for cryptography (as it is completely deterministic). You\r\nshouldn’t use it for cryptographic code.\r\n\r\nSymmetric ciphers are so-named because the key is shared across any\r\nentities. There are three key sizes for AES: 128-bit, 192-bit, and\r\n256-bit, aka 16-byte, 24-byte, and 32-byte key sizes. If you want to use\r\na passphrase, you should use a digest algorithm that produces an\r\nappropriately sized digest and hash that passphrase. For example, for\r\nAES-256, you would want to use SHA-256. Here is a sample function to\r\ngenerate an AES-256 key from a passphrase:\r\n\r\n        # generate an AES-256 key from a passphrase\r\n        def passphrase(password, readable = False):\r\n            \"\"\"\r\n            Converts a passphrase to a format suitable for use as an AES key.\r\n\r\n            If readable is set to True, the key is output as a hex digest. This is\r\n            suitable for sharing with users or printing to screen when debugging\r\n            code.\r\n\r\n            By default readable is set to False, in which case the value it \r\n            returns is suitable for use directly as an AES-256 key.\r\n            \"\"\"\r\n            key     = Crypto.Hash.SHA256.new(password)\r\n        \r\n            if readable:\r\n                return key.hexdigest()\r\n            else:\r\n                return key.digest()\r\n\r\nWe could include this a set of AES encryption and decryption functions:\r\n\r\n         mode = Crypto.Cipher.AES.MODE_CBC       # shortcut to clean up code\r\n\r\n         # AES-256 encryption using a passphrase\r\n         def passphrase_encrypt(password, iv, data):\r\n            key     = passphrase(password)\r\n            data    = pad_data(data)\r\n            aes     = Crypto.Cipher.AES.new(key, mode, iv)\r\n\r\n            return aes.encrypt(data)\r\n\r\n        # AES-256 decryption using a passphrase\r\n        def passphrase_decrypt(password, iv, data):\r\n            key     = passphrase(password)\r\n            aes     = Crypto.Cipher.AES.new(key, mode, iv)\r\n            data    = aes.decrypt(data)\r\n\r\n            return unpad_data(data)\r\n\r\nNotice how the data is padded before being encrypted and unpadded after\r\ndecryption - the decryption process will not remove the padding on its\r\nown.\r\n\r\nOf course, storing the password is another matter entirely; I\r\nrecommend [PBKDF2](https://en.wikipedia.org/wiki/Pbkdf2). Other\r\noptions include [bcrypt](https://en.wikipedia.org/wiki/Bcrypt) and\r\n[scrypt](https://en.wikipedia.org/wiki/Scrypt). For symmetric\r\nciphers, it is better to use a completely randomly generated password.\r\n\r\nThe [`pbkdf2` package](http://pypi.python.org/pypi/pbkdf2/) in PyPI\r\nis a Python implementation of PBKDF2.  The example from the [package's\r\nwebpage](https://www.dlitz.net/software/python-pbkdf2/) is very\r\nclear:\r\n\r\n        from PBKDF2 import PBKDF2\r\n            from Crypto.Cipher import AES\r\n            import os\r\n        \r\n            salt = os.urandom(8)    # 64-bit salt\r\n            key = PBKDF2(\"This passphrase is a secret.\", salt).read(32) # 256-bit key\r\n            iv = os.urandom(16)     # 128-bit IV\r\n            cipher = AES.new(key, AES.MODE_CBC, iv)\r\n\r\nUnless you are you doing interactive encryption, passphrase encryption\r\nwon’t be terribly useful. Instead, we just need to generate 32 random\r\nbytes (and make sure we keep track of it) and use that as the key:\r\n\r\n        # generate a random AES-256 key\r\n        def generate_aes_key():\r\n            rnd     = Crypto.Random.OSRNG.posix.new().read(KEY_SIZE)\r\n            return rnd\r\n\r\nWe can use this key directly in the AES transformations:\r\n\r\n        def encrypt(key, iv, data):\r\n            aes     = Crypto.Cipher.AES.new(key, mode, iv)\r\n            data    = pad_data(data)\r\n\r\n            return aes.encrypt(data)\r\n\r\n        def decrypt(key, iv, data):\r\n            aes     = Crypto.Cipher.AES.new(key, mode, iv)\r\n            data    = aes.decrypt(data)\r\n\r\n            return unpad_data(data)\r\n\r\nThat should cover the basics of block cipher encryption. We’ve gone over\r\nkey generation, padding, and encryption / decryption. AES-256 isn’t the\r\nonly block cipher provided by the PyCrypto package; however, it is the\r\nstandard and well-vetted.\r\n\r\nASCII-Armouring\r\n===============\r\n\r\nI’m going to take a quick detour and talk about ASCII armouring.\r\nIf you’ve played with the crypto functions above, you’ll notice\r\nthey produce an annoying dump of binary data that can be a hassle\r\nto deal with. One common technique for making the data a little bit\r\neasier to deal with is to encode it with\r\n[base64](https://secure.wikimedia.org/wikipedia/en/wiki/Base64).\r\nThere are a few ways to incorporate this into python:\r\n\r\nAbsolute Base64 Encoding\r\n------------------------\r\n\r\nThe easiest way is to just base64 encode everything in the encrypt\r\nfunction. Everything that goes into the decrypt function should be in\r\nbase64 - if it’s not, the `base64` module will throw an error: you could\r\ncatch this and then try to decode it as binary data.\r\n\r\nA Simple Header\r\n---------------\r\n\r\nA slightly more complex option, and the one I adopt in this article, is\r\nto use a `\\x00` as the first byte of the ciphertext for binary data, and\r\nto use `\\x41` (an ASCII “`A`”) for ASCII encoded data. This will\r\nincrease the complexity of the encryption and decryption functions\r\nslightly. We’ll also pack the initialisation vector at the beginning of\r\nthe file as well. Given now that the `iv` argument might be `None` in\r\nthe decrypt function, I will have to rearrange the arguments a bit; for\r\nconsistency, I will move it in both functions. I leave adding it into\r\nthe `passphrase_encrypt` and `passphrase_decrypt` functions as an\r\nexercise for the reader. My modified functions look like this now:\r\n\r\n        def encrypt(key, data, iv, armour = False):\r\n            aes     = Crypto.Cipher.AES.new(key, mode, iv)\r\n            data    = pad_data(data)\r\n            ct      = aes.encrypt(data)         # ciphertext\r\n            ct      = iv + ct                   # pack the initialisation vector in\r\n        \r\n            # ascii-armouring\r\n            if armour:\r\n                ct = '\\x41' + base64.encodestring(ct)\r\n            else:\r\n                ct = '\\x00' + ct\r\n\r\n            return ct\r\n\r\n        def decrypt(key, data, iv = None):\r\n            # remove ascii-armouring if present\r\n            if data[0] == '\\x00':\r\n                data = data[1:]\r\n            elif data[0] == '\\x41':\r\n                data = base64.decodestring(data[1:])\r\n\r\n            iv      = data[:16]\r\n            data    = data[16:]\r\n            aes     = Crypto.Cipher.AES.new(key, mode, iv)\r\n            data    = aes.decrypt(data)\r\n            return unpad_data(data)\r\n\r\nA More Complex Container\r\n------------------------\r\n\r\nThere are more complex ways to do it (and you’ll see it with the public\r\nkeys in the next section) that involve putting the base64 into a\r\ncontainer of sorts that contains additional information about the key.\r\n\r\nPublic Key Cryptography\r\n=======================\r\n\r\nNow it is time to take a look at public-key cryptography. Public-key\r\ncryptography, or PKC, involves the use of two-part keys. The private key\r\nis the sensitive key that should be kept private by the owning entity,\r\nwhereas the public key (which is generated from the private key) is\r\nmeant to be distributed to any entities which must communicate securely\r\nwith the entity owning the private key. Confusing? Let’s look at this\r\nusing the venerable Alice and Bob, patron saints of cryptography.\r\n\r\nAlice wants to talk to Bob, but doesn’t want Eve to know the contents of\r\nthe message. Both Alice and Bob generate a set of private keys. From\r\nthose private keys, they both generate public keys. Let’s say they post\r\ntheir public keys on their websites. Alice wants to send a private\r\nmessage to Bob, so she looks up Bob’s public key from his site. (In\r\nfact, there is a way to distribute keys via a central site or entity;\r\nthis is called a public key infrastructure (PKI)). The public key can be\r\nused as the key to encrypt a message with PKC. The resulting ciphertext\r\ncan only be decrypted using Bob’s private key. Alice sends Bob the\r\nresulting ciphertext, which Eve cannot decrypt without Bob’s private\r\nkey. Hopefully this is a little less confusing.\r\n\r\nOne of the most common PKC systems is RSA (which is an acronym for\r\nthe last names of the designers of the algorithm). Generally, RSA\r\nkeys are 1024-bit, 2048-bit, or 4096-bits long. The keys are most\r\noften in\r\n[PEM](https://secure.wikimedia.org/wikipedia/en/wiki/Privacy-enhanced\r\nElectronic Mail) or\r\n[DER](https://secure.wikimedia.org/wikipedia/en/wiki/Distinguished Encoding\r\nRules) format. Generating RSA keys with PyCrypto is extremely easy:\r\n\r\n        def generate_key(size):\r\n            PRNG    = Crypto.Random.OSRNG.posix.new().read\r\n            key     = Crypto.PublicKey.RSA.generate(size, PRNG)\r\n\r\n            return key\r\n\r\nThe `key` that is returned isn’t like the keys we used with the block\r\nciphers. It is an RSA object and comes with several useful built-in\r\nmethods. One of these is the `size()` method, which returns the size of\r\nthe key in bits minus one. For example:\r\n\r\n        >>> import publickey\r\n        >>> key = publickey.generate_key( 1024 )\r\n        >>> key.size()\r\n        1023\r\n        >>>\r\n\r\nA quick note: I will use 1024-bit keys in this tutorial because they are\r\nfaster to generate, but in practice you should be using at least\r\n2048-bit keys. The key also includes encryption and decryption methods\r\nin the class:\r\n\r\n        >>> import publickey\r\n        >>> import base64\r\n        >>> message = 'Test message...'\r\n        >>> ciphertext = key.encrypt(message, None)\r\n        >>> print base64.encodestring(ciphertext[0])\r\n        gzA9gXfHqnkValdhhYjRVVSxuygx48i66h0vFUnmVu8FZXJtmaACvNDo43D0vjjHzFiblE1eCFiI\r\n        xlhVuHxldWXJSnARgWX1bTY7imR9Hve+WQC8rl+qB5xpq3xnKH7/z8/5YdLvCo/knXYE1cI/XYJP\r\n        EP1nA6bUZNj6bD1Zx4w=\r\n\r\nThe `None` that is passed into the encryption function is part of the\r\nPyCrypto API for those public key ciphers requiring an additional random\r\nnumber function to be passed in. It returns a tuple containing only the\r\nencrypted message. In order to pass this to the decryption function, we\r\nneed to pass only the encrypted message as a string:\r\n\r\n         >>> ciphertext = key.encrypt(message, None)[0]\r\n         >>> key.decrypt(ciphertext)\r\n         'Test message...'\r\n\r\nWhile these are simple enough, we could put them into a pair of\r\nfunctions that also include ASCII-armouring:\r\n\r\n        def encrypt(key, message, armour = True):\r\n            ciphertext  = key.encrypt( message, None )\r\n            ciphertext  = ciphertext[0]\r\n\r\n            if armour:\r\n                ciphertext = '\\x41' + base64.encodestring( ciphertext )\r\n            else:\r\n                ciphertext = '\\x00' + base64.encodestring( ciphertext )\r\n\r\n            return ciphertext\r\n\r\n        def decrypt(key, message):\r\n            if   '\\x00' == message[0]:\r\n                message = message[1:]\r\n            elif '\\x41' == message[0]:\r\n                message == base64.decodestring( message[1:] )\r\n\r\n            plaintext   = key.decrypt( message )\r\n            return plaintext\r\n\r\nThese two functions present a common API that will simplify encryption\r\nand decryption and make it a little easier to read. Assuming we still\r\nhave the same `message` definition as before:\r\n\r\n        >>> ciphertext = publickey.encrypt(key, message)\r\n        >>> publickey.decrypt(key, ciphertext)\r\n        'Test message...'\r\n\r\nNow, what if we want to export this generated key and read it in later?\r\nThe key comes with the method `exportKey()`. If the key is a private\r\nkey, it will export the private key; if it is a public key, it will\r\nexport the public key. We can write functions to backup our private key\r\n(which **absolutely** needs to be kept secure) and a function to export\r\nour public key, suitable for uploading to our web page or to a PKI\r\nkeystore:\r\n\r\n        # backup our key, whether public or private\r\n        def export_key(filename, key):\r\n            try:\r\n                f = open(filename, 'w')\r\n            except IOError as e:\r\n                print e\r\n                raise\r\n            else:\r\n                f.write( key.exportKey() )\r\n                f.close()\r\n\r\n        # will only export the public key\r\n        def export_pubkey(filename, key):\r\n            try:\r\n                f = open(filename, 'w')\r\n            except IOError as e:\r\n                print e\r\n                raise\r\n            else:\r\n                f.write( key.publickey().exportKey() )\r\n                f.close()\r\n\r\nImporting a key is done using the RSA.importKey function:\r\n\r\n        def load_key(filename):\r\n            try:\r\n                f = open(filename)\r\n            except IOError as e:\r\n                print e\r\n                raise\r\n            else:\r\n                key = Crypto.PublicKey.RSA.importKey(f.read())\r\n                f.close()\r\n            return key\r\n\r\nWe can take a look at the difference between the public and private\r\nkeys:\r\n\r\n        >>> key = publickey.generate_key( 1024 )\r\n        >>> print key.exportKey()\r\n        -----BEGIN RSA PRIVATE KEY-----\r\n        MIICXAIBAAKBgQCpVA2pqLuS1fmutvx/lBhlk+UMXWcZKVzh+n5D6Hv/ZWhlzRuC\r\n        q408uhVBUD32ylbQ2iFdhA1leq0xWRGQ8Y3LlO6tQZ0gC2oOHetX3YOghO3q4yMe\r\n        wvuU+Wb6bS1aRDc9YV3IMPjQW47MOROUldjMEdJJhfxko5YZuaghhpd56wIDAQAB\r\n        AoGAaRznellnT2iLHX00U1IwruXXOwzEUmdN5G4mcathRhLCcueXW095VqhBR5Ez\r\n        Vf8XU4EFU1MFKei0mLys3ehFV4aoTfU1xm91jXNZrM/rIjHQQObx2fcDSgrM9iyd\r\n        kcgGrz5nDvsyxAxOwxCh96vNxZZYTWa8Zcqng1XYeW93nFkCQQC8Rqwn9Sa1UjBB\r\n        mIepkcdYfflkzmD7IBcgiTmGFQ9NXiehY6MQd0UJoFYGBEknPazzWQbNVpkZO4TR\r\n        oPuKNjSNAkEA5jyWJhKyq2BVD6UP77vYTJu48OhLx4J7qb3DKHnk5syOBnbke2Df\r\n        KV1VjRsipSjb4EXAWhWaqnTfPPDbvyWWVwJAWUgSP2iLkJSG+bRBMPJGW/pxF5Ke\r\n        fre6/9zTAHhgJ0os9OVw4FAO1v/Hi1bg8dDXgRaImTsloseMtnPmlKYbyQJAbmbr\r\n        EQKyTl95KnFaPPj0dXfOrSaW/+pf5jsqlAQvcUTxbcQhN9Bx8mHhHjK+4DfBh7+q\r\n        xwfJDKfSTGSq2vPpLQJBAL5irIeHoFESPZZI1NW7OkpKPcO/2ps9NkhgZJQ7Pc11\r\n        lWh6Ch2cnBzZmeh6lN/zC4l3mLVhdZSXkEKOzeuFpBs=\r\n        -----END RSA PRIVATE KEY-----\r\n        >>> pk = key.publickey()\r\n        >>> print pk.exportKey()\r\n        -----BEGIN PUBLIC KEY-----\r\n        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpVA2pqLuS1fmutvx/lBhlk+UM\r\n        XWcZKVzh+n5D6Hv/ZWhlzRuCq408uhVBUD32ylbQ2iFdhA1leq0xWRGQ8Y3LlO6t\r\n        QZ0gC2oOHetX3YOghO3q4yMewvuU+Wb6bS1aRDc9YV3IMPjQW47MOROUldjMEdJJ\r\n        hfxko5YZuaghhpd56wIDAQAB\r\n        -----END PUBLIC KEY-----\r\n\r\nUsing the `export_pubkey()` function, you can pass that file around to\r\npeople to encrypt messages to you. Often, you wil want to generate a\r\nkeypair to give to people. One convention is to name the secret key\r\n’keyname.prv’ (prv for private) and the public key ’keyname.pub’. We\r\nwill follow that convention in an `export_keypair()` function:\r\n\r\n        def export_keypair(basename, key):\r\n            pubkeyfile   = basename + '.pub'\r\n            prvkeyfile   = basename + '.prv'\r\n\r\n            export_key(prvkeyfile, key)\r\n            export_pubkey(pubkeyfile, key)\r\n\r\nFor example, Bob generates a keypair and emails the public key to Alice:\r\n\r\n         >>> key = publickey.generate_key( 1024 )\r\n         >>> key.size()\r\n         1023\r\n         >>> key.has_private()\r\n         True\r\n         >>> publickey.export_keypair('bob.prv', key)\r\n         >>> \r\n\r\nThen, assuming Bob gave Alice `bob.pub`:\r\n\r\n        >>> bob = publickey.load_key('./bobpub')\r\n        >>> message = 'secret message from Alice to Bob'\r\n        >>> print publickey.encrypt(bob, message)\r\n        AN6RsuXEeKicUZKtZCsDeqGKeB5em+NG/bgoqr9l8ij2o1Gr9sT69tv0zxgmigK/Jt+gPxg/EDu61\r\n        nHmAK0XQV7BvJS5jLuBxdJ0mEpysVClu46XN1KHU2l2DsGht9e8OFvhEfDkI5t/cy/gXr0xz/EUi\r\n        rqo8qLd9Mw6TerM8gs8=\r\n\r\nThe ASCII-armoured format makes it convenient for Alice to paste the\r\nencrypted message to Bob, so she does, and now Bob has it on his\r\ncomputer. To read it, he does something similar:\r\n\r\n        >>> bob = publickey.load_key('tests/bob.prv')\r\n        >>> print publickey.decrypt(bob, message)\r\n        secret message from Alice to Bob\r\n\r\nAt this point, Bob can’t be sure that the message came from Alice but he\r\ncan read the message. We’ll cover entity authentication in a later\r\nsection, but first, there’s something else I’d to point out:\r\n\r\nYou might have noticed at this point that public key cryptography\r\nappears to be a lot simpler than symmetric key cryptography. The\r\nkey distribution problem is certainly easier, especially with a\r\nproper PKI.  Why would anyone choose to use symmetric key cryptography\r\nover public key cryptography? The answer is performance: if you\r\ncompare the block cipher test code (if you don’t have a copy of\r\nthis code, you can get it at the [tutorial’s github\r\npage](https://github.com/kisom/crypto_intro)) with the public key\r\ntest code, you will notice that the block cipher code is orders of\r\nmagnitude faster. It also generates far more keys than the public\r\nkey code. There is a solution to this problem: hybrid cryptosystems.\r\n\r\nHybrid cryptosystems use public key cryptography to establish a\r\nsymmetric session key. Both\r\n[**TLS**](https://secure.wikimedia.org/wikipedia/en/wiki/Transport_Layer_Security)\r\n(Transport Layer Security), and its predecessor **SSL** (Secure\r\nSockets Layer), most often used to secure HTTP transactions, use a\r\nhybrid cryptosystem to speed up establishing a secure session.  PGP\r\n(and hence GnuPG) also uses hybrid crypto.\r\n\r\nLet’s say Alice and Bob wish to use hybrid crypto. If Alice initiates\r\nthe session, she should be the one to generate the session key. For\r\nexample,\r\n\r\n         >>> import block, publickey\r\n         >>> session_key = block.generate_aes_key()\r\n         >>> alice_key   = publickey.load_key('keys/alice.prv')\r\n         >>> bob_key     = publickey.load_key('keys/bob.pub')\r\n         >>> encrypted_session_key = encrypt( bob_key, session_key )\r\n\r\nAt this point, Alice should send Bob the `encrypted_session_key`; she\r\nshould retain a copy as well. They can then use this key to communicate\r\nusing the much-faster AES256.\r\n\r\nIn communicating, it might be wise to create a message format that packs\r\nin the session key into a header, and encrypts the rest of the body with\r\nthe session key. This is a subject beyond the realm of a quick tutorial\r\n- again, consult with the people who do this on a regular basis.\r\n\r\nDigital Signatures\r\n==================\r\n\r\nIn all of the previous examples, we assumed that the identity of the\r\nsender wasn’t a question. For a symmetric key, that’s less of a stretch\r\n- there’s no differentiation between owners. Public keys, however, are\r\nsupposed to be associated with an entity. How can we prove the identity\r\nof the user? Without delving into too much into social sciences and\r\ntrust metrics and a huge philosophical argument, let’s look at the\r\nbasics of signatures.\r\n\r\nA signature works similarly to encryption, but in reverse, and it is\r\nslightly different: a hash of the message is ’encrypted’ by the private\r\nkey to the public key. The public key is used to ’decrypt’ this\r\nciphertext. Contrast this to actual public key encryption: the entire\r\nmessage is encrypted to the private key by the public key, and the\r\nprivate key is used to decrypt the ciphertext. With signatures, the\r\n’encrypted’ hash of the message is called the signature, and the act of\r\n’encryption’ is termed ’signing’. Similarly, the ’decryption’ is known\r\nas verification or verifying the signature.\r\n\r\nPyCrypto’s PublicKey implementations already come with signatures and\r\nverification methods for keys using sign() and verify(). The signature\r\nis a long in a tuple:\r\n\r\n        >>> key.sign( d, None )\r\n        (1738423518152671545669571445860037944518162197656333123466248015147955424248\r\n    876723731383711018550231967374810686606623315483033485630977014574359346192927942\r\n    623807461783144628656796225504478196458051789241311033020911767301220653148276004\r\n    0551357526383627059382081878791040169815009051016949220178044764130908L,)\r\n\r\nWe can write our own functions to wrap around these two functions and\r\nperform ASCII-armouring if desired. Our signature function should take a\r\nkey and a message, and optionally a flag to ASCII armour the signature;\r\nit should return a signed digest of the message:\r\n\r\n        def sign(key, message, armour = True):\r\n            if not key.can_sign(): \r\n                return None\r\n\r\n            digest      = Crypto.Hash.SHA256.new(message).digest()\r\n            signature   = key.sign( digest, None )[0]\r\n\r\n            if armour:\r\n                sig     = base64.encodestring( str(signature) )\r\n            else:\r\n                sig     = str( signature )\r\n        \r\n            return sig.strip()\r\n\r\nThe signature is converted to a string to make it easier to pack it into\r\nstructures and also to give us consistent input to the verify()\r\nfunction.\r\n\r\nVerifying the signature requires that we determine if the signature is\r\nASCII-armoured or not, then comparing a digest of the message to the\r\nsignature:\r\n\r\n        def verify(key, message, signature):\r\n            try:\r\n                sig     = long( signature )\r\n            except ValueError as e:\r\n                sig     = long( base64.decodestring( signature.rstrip('\\n') ), )\r\n\r\n            digest      = Crypto.Hash.SHA256.new(message).digest()\r\n            return key.verify( digest, (sig, ) )\r\n\r\nThe sign() function returns a signature and the verify() function\r\nreturns a boolean. Now, Alice can sign her message to Bob, and Bob knows\r\nthe key belongs to Alice. She sends Bob the signature and the encrypted\r\nmessage. Bob then makes sure Alice’s key properly verifies the signature\r\nto the encrypted message.\r\n\r\nKey Exchange\r\n============\r\n\r\nSo how does Bob know the key actually belongs to Alice? There are two\r\nmain schools of thought regarding the authentication of key ownership:\r\ncentralised and decentralised. TLS/SSL follow the centralised school: a\r\nroot certificate[^1] authority (CA) signs intermediary CA keys, which\r\nthen sign user keys. For example, if Bob runs Foo Widgets, LLC, he can\r\ngenerate an SSL keypair. From this, he generates a certificate signing\r\nrequest, and sends this to the CA. The CA, usually after taking some\r\nmoney and ostensibly actually verifying Bob’s identity[^2], then signs\r\nBob’s certificate. Bob sets up his webserver to use his SSL certificate\r\nfor all secure traffic, and Alice sees that the CA did in fact sign his\r\ncertificate. This relies on trusted central authorities, like\r\nVeriSign[^3]. Alice’s web browser would ship with a keystore of select\r\ntrusted CA public keys (like VeriSigns) that she could use to verify\r\nsignatures on the certificates from various sites. This system is called\r\na public key infrastructure.\r\n\r\nThe other school of thought is followed by PGP (and GnuPG) - the\r\ndecentralised model. In PGP, this is manifested as the [Web of\r\nTrust](http://www.rubin.ch/pgp/weboftrust.en.html). For example,\r\nif Carol now wants to talk to Bob and gives Bob her public key, Bob\r\ncan check to see if Carol’s key has been signed by anyone else.\r\nWe’ll also say that Bob knows for a fact that Alice’s key\r\nbelongs to Alice, and he trusts her[^4], and that Alice has signed\r\nCarol’s key. Bob sees Alice’s signature on Carol’s key and then can be\r\nreasonably sure that Carol is who she says it was. If we repeat the\r\nprocess with Dave, whose key was signed by Carol (whose key was signed\r\nby Alice), Bob might be able to be more certain that the key belongs to\r\nDave, but maybe he doesn’t really trust Carol to properly verify\r\nidentities. In PGP, Bob can mark keys as having various trust levels,\r\nand from this a web of trust emerges: a picture of how well you can\r\ntrust that a given key belongs to a given user.\r\n\r\nThe key distribution problem is not a quick and easy problem to\r\nsolve; a lot of very smart people have spent a lot of time coming\r\nup with solutions to the problem. There are key exchange protocols\r\n(such as the [Diffie-Hellman key exchange](http://is.gd/Tr0zLP) and\r\n[IKE](https://secure.wikimedia.org/wikipedia/en/wiki/Internet_Key_Exchange)\r\n(which uses Diffie-Hellman) that provide alternatives to the web\r\nof trust and public key infrastructures.\r\n\r\nReferences\r\n==========\r\n\r\n* A. J. Menezes, P. C. van Oorschot, and S. A. Vanstone. *The\r\nHandbook of Applied Cryptography*, CRC Press, 5th printing, October\r\n1996.\r\n\r\n* B. Schneier. *Applied Cryptography, Second Edition*, John Wiley\r\nand Sons, 1996.\r\n\r\n* PyCrypto API Documentation.\r\nhttps://www.dlitz.net/software/pycrypto/apidoc/\r\n\r\nEndnotes\r\n========\r\n\r\n[^1]: A certificate is a public key encoded with X.509 and which\r\ncan have additional informational attributes attached, such as\r\norganisation name and country.\r\n\r\n[^2]: The extent to which this actually happens varies widely based\r\non the different CAs.\r\n\r\n[^3]: There is some question as to whether VeriSign can actually\r\nbe trusted, but that is another discussion for another day...\r\n\r\n[^4]: It is quite often important to distinguish between *I know\r\nthis key belongs to that user* and *I trust that user*. This is\r\nespecially important with key signatures - if Bob cannot trust Alice\r\nto properly check identities, she might sign a key for an identity\r\nshe hasn’t checked.\r\n\r\n","name":"A Working Introduction to Cryptography"}